/*
 * This file is part of the AprilTag library.
 *
 * AprilTag is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * AprilTag is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Libav; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#ifndef _APRILTAG_H
#define _APRILTAG_H

#include <stdlib.h>

#include "matd.h"
#include "image_u8.h"
#include "zarray.h"
#include "workerpool.h"
#include "pthread.h"
#include "timeprofile.h"

#define APRILTAG_TASKS_PER_THREAD_TARGET 10

// This struct is factored out in order to support pluggable
// segmentation systems.  Most users will not need to ever use this
// struct.
struct segment
{
    float p0[2];
    float p1[2];

    float theta;

    // a list of the points that are near p1
    zarray_t *neighbors;
};

// Represents a tag family. Every tag belongs to a tag family. Tag
// families are generated by the Java tool
// april.tag.TagFamilyGenerator and can be converted to C using
// april.tag.TagToC.
typedef struct april_tag_family april_tag_family_t;
struct april_tag_family
{
    // How many codes are there in this tag family?
    uint32_t ncodes;

    // The codes in the family.
    uint64_t *codes;

    // how wide (in bit-sizes) is the black border? (usually 1)
    uint32_t black_border;

    // how many bits tall and wide is it? (e.g. 36bit tag ==> 6)
    uint32_t d;

    // minimum hamming distance between any two codes. (e.g. 36h11 => 11)
    uint32_t h;
};

// Represents a detector object. Upon creating a detector, all fields
// are set to reasonable values, but can be overridden by accessing
// these fields.
typedef struct april_tag_detector april_tag_detector_t;
struct april_tag_detector
{
    ///////////////////////////////////////////////////////////////
    // User-configurable parameters.

    // How many threads should be used?
    int nthreads;

    // detection of quads can be done on a lower-resolution image,
    // improving speed at a cost of pose accuracy and a slight
    // decrease in detection rate. Decoding the binary payload is
    // still done at full resolution. .
    float seg_decimate;

    // What Gaussian blur should be applied to the segmented image?
    // Parameter is the standard deviation in pixels.  Very noisy
    // images benefit from non-zero values (e.g. 0.8).
    float seg_sigma;

    // During segmentation, ignore pixels whose gradient magnitude
    // (squared) is less than the value below. This is computed with
    // respect to pixel values [0, 255].
    int min_mag;

    // During segmentation, we join clusters that have similar
    // directions.  This threshold is the cosine of the maximum angle
    // between two segments that will be joined.
    float costhresh0;

    // Minimum number of pixels in a segment. Used to cull out silly
    // small segments (and avoid subsequent processing on them). (User
    // settable).
    int min_segment_size;

    // minimum (squared) gradient for an edge. Used to cull out silly
    // bad edges (and avoid subsequent processing on them). (User
    // settable).
    int min_edge_score;

    // When we build our model of black & white pixels, we add an
    // extra check that the white model must be (overall) brighter
    // than the black model.  How much brighter? (in pixel values,
    // [0,255]). .
    int min_white_black_diff;

    // Used to cull very short segments (in pixels). .
    float min_segment_length;

    // how far away can two segments be (in pixels) for them to be
    // considered "adjacent". Larger values lead to more aggressive
    // quad-making. .
    float max_segment_distance;

    // Minimum tag size (in pixels). Used to cull too-small
    // tags. .
    float min_tag_size;

    // Maximum aspect ratio, used to cull hopelessly distorted
    // tags.
    float max_aspect_ratio;

    // Reject quads where pairs of edges have angles that are close to
    // straight or close to 180 degrees. Zero means that no quads are
    // rejected. (In radians).
    float critical_rad;

    // EXPERIMENTAL. When non-zero, enables an aggressive optimization to
    // improve detection rates by twiddling the quad boundaries. This mode is
    // relatively slow and increases false positive rate and might decrease
    // pose estimation accuracy.
    int small_tag_refinement;

    // When non-zero, write a variety of debugging images to the
    // current working directory at various stages through the
    // detection process. (Somewhat slow).
    int debug;

    // when searching for neighbors, we prune the list of candidates
    // based on a weighted combination of features. When the number of
    // neighbor candidates is relatively small, pruning them is
    // unnecessary from a computational perspective. However, on
    // cluttered background, pruning can be very helpful in reducing
    // wasted search time..
    //
    // k1: An ideal "head on" tag has 90 degree turns between
    // edges. We can penalize deviations from this. (should be
    // negative)
    //
    // k2: The distance between the end of the last segment and the
    // beginning of the current segment is dist2. The length of the
    // last segment is length2. Ideally, we want dist2 to be zero, but
    // it will generally be non-zero. (should be negative)
    //
    // k3: We can assign a bonus for long edges.
    //
    // k1*fabs(dtheta - M_PI/2) + k2*sqrtf(dist2/length2) + k3*sqrtf(dist3) + 1
    //
    // If the expression is greater than or equal to zero, the neighbor is accepted.
    //
    float neighbor_k1;
    float neighbor_k2;
    float neighbor_k3;

    ///////////////////////////////////////////////////////////////
    // Statistics relating to last processed frame
    timeprofile_t *tp;

    uint32_t nedges;
    uint32_t nsegments;
    uint32_t nquads;

    ///////////////////////////////////////////////////////////////
    // Internal variables below

    // Not freed on april_tag_destroy; a tag family can be shared
    // between multiple users. The user should ultimately destroy the
    // tag family passed into the constructor.
    zarray_t *tag_families;

    // Used to manage multi-threading.
    workerpool_t *wp;

    // Used for thread safety.
    pthread_mutex_t mutex;
};

// Represents the detection of a tag. These are returned to the user
// and must be individually destroyed by the user.
typedef struct april_tag_detection april_tag_detection_t;
struct april_tag_detection
{
    // a pointer for convenience. not freed by april_tag_detection_destroy.
    april_tag_family_t *family;

    // The decoded ID of the tag
    int id;

    // How many error bits were corrected? Note: accepting large numbers of
    // corrected errors leads to greatly increased false positive rates.
    int hamming;

    // A measure of the quality of the binary decoding process: the
    // average difference between the intensity of a data bit versus
    // the decision threshold. Higher numbers roughly indicate better
    // decodes.
    float goodness;

    // The 3x3 homography matrix describing the projection from an
    // "ideal" tag (with corners at (-1,-1), (1,-1), (1,1), and (-1,
    // 1)) to pixels in the image. This matrix will be freed by
    // april_tag_detection_destroy.
    matd_t *H;

    // The center of the detection in image pixel coordinates.
    double c[2];

    // The corners of the tag in image pixel coordinates. These always
    // wrap counter-clock wise around the tag.
    double p[4][2];
};

// Create an april tag detector. After creation, parameters may be
// modified.
april_tag_detector_t *april_tag_detector_create(april_tag_family_t *fam);

// Destroy the april tag detector (but not the underlying
// april_tag_family_t used to initialize it.)
void april_tag_detector_destroy(april_tag_detector_t *td);

// Detect tags from an image and return an array of
// april_tag_detection_t*.
zarray_t *april_tag_detector_detect(april_tag_detector_t *td, image_u8_t *im_orig);

// Call this method on each of the tags returned by april_tag_detector_detect
void april_tag_detection_destroy(april_tag_detection_t *det);

#endif
